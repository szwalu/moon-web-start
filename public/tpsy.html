<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
    <title>离线图片水印工具</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
        }

        #container {
            max-width: 1200px;
            margin: 0 auto;
        }

        #graph {
            display: grid;
            grid-gap: 10px;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }

        p, article {
            margin: 0 0 1.5rem 0;
        }

        article {
            font-size: 0.9rem;
            color: #777;
        }

        .align-center-box {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 1rem;
            gap: 10px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-right: 20px;
        }

        label {
            color: blue;
            font-size: 1.1rem;
            margin-right: 10px;
        }

        .control-group label, .format-group label {
            color: black;
            font-size: 1rem;
            min-width: 80px;
        }

        input#text {
            width: 100%;
            box-sizing: border-box;
            font-size: 1rem;
            padding: 8px;
            margin-bottom: 10px;
        }

        input[type=range] {
            width: 350px;
            height: 18px;
            vertical-align: middle;
        }

        input[type=color] {
            width: 40px;
            height: 40px;
            padding: 0;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid blue;
        }

        select {
            width: 250px;
        }

        canvas {
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            height: auto; /* 保持宽高比 */
            border: 1px dashed #AAA;
            cursor: pointer;
            display: block; /* 防止 inline 样式导致偏移 */
        }

        .label {
            min-width: 50px;
        }

        button {
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
        }

        select, input[type=file], input[type=checkbox], input[type=radio] {
            font-size: 1rem;
            padding: 5px;
        }

        .format-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        @media (max-width: 768px) {
            #container {
                padding: 10px;
            }

            #graph {
                grid-template-columns: 1fr;
            }

            .align-center-box {
                flex-direction: column;
                align-items: flex-start;
            }

            .control-group {
                flex-direction: row;
                width: 100%;
                margin-right: 0;
            }

            .control-group label, .format-group label {
                font-size: 0.9rem;
                min-width: 70px;
            }

            input[type=range] {
                width: 270px;
            }

            select {
                width: 100%;
                max-width: 200px;
            }

            input[type=color] {
                width: 35px;
                height: 35px;
                border-radius: 50%;
                border: 2px solid blue;
            }

            button, select, input[type=file], input#text {
                width: 100%;
                box-sizing: border-box;
            }

            .label {
                min-width: 40px;
            }

            h1 {
                font-size: 1.5rem;
            }

            article {
                font-size: 0.85rem;
            }

            .format-group {
                flex-wrap: wrap;
                gap: 10px;
            }

            canvas {
                max-width: 100%;
                height: auto; /* 确保移动端保持宽高比 */
            }
        }

        @media (max-width: 480px) {
            label {
                font-size: 0.9rem;
            }

            .control-group label, .format-group label {
                font-size: 0.8rem;
                min-width: 60px;
            }

            button, select, input {
                font-size: 0.9rem;
            }

            input[type=range] {
                width: 230px;
            }

            select {
                width: 100%;
                max-width: 180px;
            }

            input[type=color] {
                width: 30px;
                height: 30px;
                border-radius: 50%;
                border: 2px solid blue;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
<div id="container">
    <h1>离线图片水印工具</h1>
    <article>
        安全地为图片加水印，无任何网络请求，特别适合各种敏感证件（身份证，驾照，护照等）。
    </article>

    <div class="align-center-box">
        <label for="image">第一步：先选择本地图片(可多选)</label>
        <input type="file" id="image" autocomplete="off" multiple>
        <label for="text">第二步：输入需要打水印的文字</label>
        <input id="text" autocomplete="off" placeholder="请输入文字">
    </div>

    <div class="align-center-box">
        <div class="control-group">
            <label for="color">颜色</label>
            <input type="color" id="color" value="#FFFFFF">
            <label class="label" id="label-color"></label>
        </div>

        <div class="control-group">
            <label for="fontSelect">字体</label>
            <select id="fontSelect"></select>
        </div>

        <div class="control-group">
            <label for="alpha">透明度</label>
            <input type="range" id="alpha" min="0" max="1" step="0.01" autocomplete="off" value="0.25">
            <label class="label" id="label-alpha"></label>
        </div>

        <div class="control-group">
            <label for="size">字号</label>
            <input type="range" id="size" min="0.1" max="5" step="0.01" autocomplete="off" value="0.8">
            <label class="label" id="label-size"></label>
        </div>

        <div class="control-group">
            <label for="marginVertical">间隔</label>
            <input type="range" id="marginVertical" min="-5" max="12" step="0.1" autocomplete="off" value="3.3">
            <label class="label" id="label-marginVertical"></label>
        </div>
    </div>

    <div class="align-center-box">
        <label for="text">第三步：点击图片进行单个图片下载</label>
        <button onclick="downloadAllPic()">下载全部</button>
        <div class="format-group">
            <label>
                PNG格式
                <input type="radio" value="image/png" name="pic-type" class="pic-type" checked>
            </label>
            <label>
                JPEG格式
                <input type="radio" value="image/jpeg" name="pic-type" class="pic-type">
            </label>
            <label>
                Webp格式
                <input type="radio" value="image/webp" name="pic-type" class="pic-type">
            </label>
        </div>
        <span id="pic-quality-div" style="display: none">
            <label for="pic-quality">图像质量</label>
            <input type="range" id="pic-quality" min="1" max="100" step="1" autocomplete="off" value="95">
            <label class="label" id="label-pic-quality"></label>
        </span>
    </div>

    <p id="graph"></p>

    <script>
        let canvas;
        let $ = sel => document.querySelector(sel);
        let inputItems = ['color', 'alpha', 'size', 'marginVertical', 'pic-quality'];
        let configInputSetting = {};
        let allCanvas = [];

        let image = $('#image');
        let graph = $('#graph');
        let dataURItoBlob = (dataURI, type) => {
            let binStr = atob(dataURI.split(',')[1]);
            let len = binStr.length;
            let arr = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                arr[i] = binStr.charCodeAt(i);
            }
            return new Blob([arr], { type });
        };

        const fontOptions = ["Arial", "Helvetica", "Times New Roman", "Courier New", "Verdana", "Georgia", "Impact", "Tahoma", "Palatino", "Garamond", "Bookman", "Comic Sans MS", "Century Gothic", "Arial Black", "Lucida Console",
            "幼圆", "新宋体", "文泉驿微米黑", "微软正黑体", "微软雅黑", "宋体", "思源宋体", "思源黑体", "苹方", "隶书", "楷体", "开源字体", "华文中宋", "华文行楷", "华文新魏", "华文细黑", "华文宋体", "华文隶书", "华文楷体", "华文琥珀", "华文黑体", "华文仿宋", "华文彩云", "黑体", "汉仪雅酷黑W", "汉仪小麦体", "汉仪尚魏手书W", "汉仪旗黑", "汉仪乐喵体简", "汉仪楷体", "汉仪家书简", "汉仪黑荔枝", "汉仪大宋简", "汉仪大黑简", "汉仪程行体", "汉仪PP体简", "仿宋"];
        const selectElement = $("#fontSelect");
        for (let i = 0; i < fontOptions.length; i++) {
            const optionElement = document.createElement("option");
            optionElement.value = fontOptions[i];
            optionElement.textContent = fontOptions[i];
            optionElement.style.fontFamily = fontOptions[i];
            selectElement.appendChild(optionElement);
        }

        const redrawCanvas = (canvas, img, scaledWidth, scaledHeight) => {
            const dpr = window.devicePixelRatio || 1;
            // Set canvas pixel dimensions
            canvas.width = scaledWidth * dpr;
            canvas.height = scaledHeight * dpr;
            // Set CSS dimensions to maintain aspect ratio
            canvas.style.width = `${scaledWidth}px`;
            canvas.style.height = `${scaledHeight}px`;
            let ctx = canvas.getContext('2d', { alpha: true, desynchronized: false });
            ctx.scale(dpr, dpr);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
        };

        const downloadCanvasAsImage = (canvas, fileName) => {
            let type = configInputSetting["pic-type"] || "image/png";
            let link = document.createElement('a');
            link.download = fileName + "_watermark." + type.split("/")[1];
            let quality = type === "image/png" ? undefined : parseFloat($("#pic-quality").value) / 100;
            let imageData = canvas.toDataURL(type, quality);
            let blob = dataURItoBlob(imageData, type);
            link.href = URL.createObjectURL(blob);
            graph.appendChild(link);
            setTimeout(() => {
                link.click();
                graph.removeChild(link);
            }, 10);
        };

        const downloadAllPic = async () => {
            allCanvas.forEach(({canvas, img, fileName}) => {
                downloadCanvasAsImage(canvas, fileName);
            });
        };

        let readFile = file => {
            if (!file) {
                console.error('No file provided');
                return;
            }
            try {
                let fileReader = new FileReader();
                fileReader.onload = function () {
                    try {
                        let img = new Image();
                        img.onload = function () {
                            try {
                                const canvas = document.createElement('canvas');
                                let scaledWidth = img.width;
                                let scaledHeight = img.height;

                                // Adjust size for mobile devices to fit screen
                                const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                                if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                                    const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                                    scaledWidth = Math.round(scaledWidth * ratio);
                                    scaledHeight = Math.round(scaledHeight * ratio);
                                }

                                redrawCanvas(canvas, img, scaledWidth, scaledHeight);
                                allCanvas.push({img, canvas, fileName: file.name});

                                drawText(canvas, img, scaledWidth, scaledHeight);
                                graph.appendChild(canvas);
                                console.log(`Canvas for ${file.name} appended to #graph`);

                                canvas.addEventListener('click', () => downloadCanvasAsImage(canvas, file.name));
                            } catch (err) {
                                console.error(`Error processing image ${file.name}:`, err);
                                alert(`处理图片 ${file.name} 时出错: ${err.message}`);
                            }
                        };
                        img.onerror = function () {
                            console.error(`Failed to load image ${file.name}`);
                            alert(`无法加载图片 ${file.name}，请确保文件格式正确`);
                        };
                        img.src = fileReader.result;
                    } catch (err) {
                        console.error(`Error in image creation for ${file.name}:`, err);
                        alert(`创建图片 ${file.name} 时出错: ${err.message}`);
                    }
                };
                fileReader.onerror = function () {
                    console.error(`Failed to read file ${file.name}`);
                    alert(`读取文件 ${file.name} 失败`);
                };
                fileReader.readAsDataURL(file);
            } catch (err) {
                console.error(`Error in readFile for ${file.name}:`, err);
                alert(`处理文件 ${file.name} 时出错: ${err.message}`);
            }
        };

        const makeStyle = () => {
            let match = configInputSetting.color.value.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
            return 'rgba(' + parseInt(match[1], 16) + ',' + parseInt(match[2], 16) + ',' + parseInt(match[3], 16) + ',' + configInputSetting.alpha.value + ')';
        };

        const drawText = (canvas, img, scaledWidth, scaledHeight) => {
            redrawCanvas(canvas, img, scaledWidth, scaledHeight);
            if (!canvas) {
                return;
            }

            let textSize = configInputSetting.size.value * Math.max(15, Math.min(scaledWidth, scaledHeight) / 25);
            let textCtx = canvas.getContext('2d', { alpha: true });
            textCtx.fillStyle = makeStyle();
            textCtx.font = textSize + "px " + $("#fontSelect").value;
            textCtx.textRendering = 'optimizeLegibility';
            textCtx.textBaseline = 'middle';

            let baseWidth = textCtx.measureText('啊').width;
            let textWidth = textCtx.measureText(configInputSetting.text.value).width;
            let xAdd = textWidth + baseWidth;
            let yAdd = textWidth + configInputSetting.marginVertical.value * baseWidth;
            xAdd = Math.max(xAdd, 10);
            yAdd = Math.max(yAdd, 10);

            let border = 500;
            for (let i = -border; i < scaledWidth + border; i += xAdd) {
                for (let j = -border; j < scaledHeight + border; j += yAdd) {
                    textCtx.save();
                    textCtx.translate(i, j);
                    textCtx.fillText(configInputSetting.text.value, 0, 0);
                    textCtx.restore();
                }
            }
        };

        let picTypeInputs = document.getElementsByClassName("pic-type");
        for (let i = 0; i < picTypeInputs.length; i++) {
            let item = picTypeInputs[i];
            item.addEventListener('change', () => {
                let picQuality = $("#pic-quality-div");
                picQuality.style.display = "none";
                if (item.checked) {
                    configInputSetting["pic-type"] = item.value;
                    if ("image/webp" === item.value || "image/jpeg" === item.value) {
                        picQuality.style.display = "";
                    }
                }
            });
        }

        image.addEventListener('change', function () {
            if (!this.files || this.files.length === 0) {
                console.warn('No files selected');
                alert('未选择任何文件');
                return;
            }
            const batchFileHandler = file => {
                const type = file.type.toLowerCase();
                if (!['image/png', 'image/jpeg', 'image/webp'].includes(type)) {
                    console.warn(`Unsupported file type for ${file.name}: ${type}`);
                    alert(`文件 ${file.name} 的格式不受支持，仅支持 PNG、JPEG、WebP`);
                    return;
                }
                readFile(file);
            };
            Array.from(this.files).forEach(batchFileHandler);
        });

        configInputSetting["text"] = $('#text');
        configInputSetting["text"].addEventListener('input', () => {
            allCanvas.forEach(({canvas, img, scaledWidth, scaledHeight}) => {
                scaledWidth = img.width;
                scaledHeight = img.height;
                const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                    const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                    scaledWidth = Math.round(scaledWidth * ratio);
                    scaledHeight = Math.round(scaledHeight * ratio);
                }
                drawText(canvas, img, scaledWidth, scaledHeight);
            });
        });

        configInputSetting["fontSelect"] = $('#fontSelect');
        configInputSetting["fontSelect"].addEventListener('change', () => {
            allCanvas.forEach(({canvas, img, scaledWidth, scaledHeight}) => {
                scaledWidth = img.width;
                scaledHeight = img.height;
                const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                    const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                    scaledWidth = Math.round(scaledWidth * ratio);
                    scaledHeight = Math.round(scaledHeight * ratio);
                }
                drawText(canvas, img, scaledWidth, scaledHeight);
            });
        });

        inputItems.forEach(item => {
            let el = $('#' + item);
            configInputSetting[item] = el;
            let labelDom = "#label-" + item;
            $(labelDom) ? $(labelDom).innerText = isNaN(el.value) ? el.value : parseFloat(el.value).toFixed(2) : "";
            return el.addEventListener('input', () => {
                $(labelDom) ? $(labelDom).innerText = isNaN(el.value) ? el.value : parseFloat(el.value).toFixed(2) : "";
                allCanvas.forEach(({canvas, img, scaledWidth, scaledHeight}) => {
                    scaledWidth = img.width;
                    scaledHeight = img.height;
                    const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                    if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                        const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                        scaledWidth = Math.round(scaledWidth * ratio);
                        scaledHeight = Math.round(scaledHeight * ratio);
                    }
                    drawText(canvas, img, scaledWidth, scaledHeight);
                });
            });
        });
    </script>
</div>
</body>
</html>