<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
    <title>ç¦»çº¿å›¾ç‰‡æ°´å°å·¥å…·</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
        }

        #container {
            max-width: 1200px;
            margin: 0 auto;
        }

        #graph {
            display: grid;
            grid-gap: 10px;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }

        p, article {
            margin: 0 0 1.5rem 0;
        }

        article {
            font-size: 0.9rem;
            color: #777;
        }

        .align-center-box {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 1rem;
            gap: 10px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-right: 20px;
        }

        label {
            color: blue;
            font-size: 1.1rem;
            margin-right: 10px;
        }

        .control-group label, .format-group label {
            color: black;
            font-size: 1rem;
            min-width: 80px;
        }

        input#text {
            width: 100%;
            box-sizing: border-box;
            font-size: 1rem;
            padding: 8px;
            margin-bottom: 10px;
        }

        input[type=range] {
            width: 350px;
            height: 18px;
            vertical-align: middle;
        }

        input[type=color] {
            width: 40px;
            height: 40px;
            padding: 0;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid blue;
        }

        select {
            width: 250px;
        }

        canvas {
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            height: auto; /* ä¿æŒå®½é«˜æ¯” */
            border: 1px dashed #AAA;
            cursor: pointer;
            display: block; /* é˜²æ­¢ inline æ ·å¼å¯¼è‡´åç§» */
        }

        .label {
            min-width: 50px;
        }

        button {
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
        }

        select, input[type=file], input[type=checkbox], input[type=radio] {
            font-size: 1rem;
            padding: 5px;
        }

        .format-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        @media (max-width: 768px) {
            #container {
                padding: 10px;
            }

            #graph {
                grid-template-columns: 1fr;
            }

            .align-center-box {
                flex-direction: column;
                align-items: flex-start;
            }

            .control-group {
                flex-direction: row;
                width: 100%;
                margin-right: 0;
            }

            .control-group label, .format-group label {
                font-size: 0.9rem;
                min-width: 70px;
            }

            input[type=range] {
                width: 270px;
            }

            select {
                width: 100%;
                max-width: 200px;
            }

            input[type=color] {
                width: 35px;
                height: 35px;
                border-radius: 50%;
                border: 2px solid blue;
            }

            button, select, input[type=file], input#text {
                width: 100%;
                box-sizing: border-box;
            }

            .label {
                min-width: 40px;
            }

            h1 {
                font-size: 1.5rem;
            }

            article {
                font-size: 0.85rem;
            }

            .format-group {
                flex-wrap: wrap;
                gap: 10px;
            }

            canvas {
                max-width: 100%;
                height: auto; /* ç¡®ä¿ç§»åŠ¨ç«¯ä¿æŒå®½é«˜æ¯” */
            }
        }

        @media (max-width: 480px) {
            label {
                font-size: 0.9rem;
            }

            .control-group label, .format-group label {
                font-size: 0.8rem;
                min-width: 60px;
            }

            button, select, input {
                font-size: 0.9rem;
            }

            input[type=range] {
                width: 230px;
            }

            select {
                width: 100%;
                max-width: 180px;
            }

            input[type=color] {
                width: 30px;
                height: 30px;
                border-radius: 50%;
                border: 2px solid blue;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
    <style id="theme-style">
  :root{
    --bg:#ffffff;
    --fg:#111111;
    --muted:#777777;
    --border:#AAAAAA;
  }
  html[data-theme="dark"]{
    --bg:#0f1115;
    --fg:#eaeaea;
    --muted:#b9b9b9;
    --border:#3a3f44;
  }

  /* åªåšå¾ˆå…‹åˆ¶çš„å…¨å±€è¦†ç›–ï¼Œå°½é‡ä¸ç¢°ä½ å·²æœ‰æ ·å¼ */
  body{ background:var(--bg); color:var(--fg); }
  article{ color:var(--muted); }
  label{ color:var(--fg); }
  canvas{ border-color:var(--border); }

  /* å°æŒ‰é’®æ ·å¼ï¼ˆä¸å½±å“ä½ åŸæœ‰ buttonï¼‰ */
  .mini-fab{
    position:fixed; z-index:9999;
    width:36px; height:36px; border-radius:50%;
    border:1px solid var(--border); background:rgba(0,0,0,0.06);
    color:var(--fg); font-size:18px; line-height:36px; text-align:center;
    cursor:pointer; -webkit-user-select:none; user-select:none;
    backdrop-filter:saturate(120%) blur(2px);
  }
  html[data-theme="dark"] .mini-fab{ background:rgba(255,255,255,0.06); }

  /* å·¦ä¸Šâ€œÃ—â€å…³é—­é’®ï¼ˆå¦‚æœä½ å·²ç»åŠ è¿‡å¯å¿½ç•¥ï¼‰ */
  .close-x{
  top:4px;         /* å¾€ä¸Šç§» */
  left:6px;        /* å¯ç¨å¾®å·¦ç§»ä¸€ç‚¹ */
  width:28px;      /* ç¼©å°å°ºå¯¸ */
  height:28px;
  font-size:18px;  /* è°ƒæ•´å­—å· */
  line-height:28px;
}

  /* å³ä¸Šä¸»é¢˜æŒ‰é’® */
  .theme-toggle{ top:10px; right:10px; }
  .mini-fab:active{ transform:translateY(1px); }
</style>
    
</head>
<body>
<div id="container">
    <h1>ç¦»çº¿å›¾ç‰‡æ°´å°å·¥å…·</h1>
    <article>
        å®‰å…¨åœ°ä¸ºå›¾ç‰‡åŠ æ°´å°ï¼Œæ— ä»»ä½•ç½‘ç»œè¯·æ±‚ï¼Œç‰¹åˆ«é€‚åˆå„ç§æ•æ„Ÿè¯ä»¶ï¼ˆèº«ä»½è¯ï¼Œé©¾ç…§ï¼ŒæŠ¤ç…§ç­‰ï¼‰ã€‚
    </article>

    <div class="align-center-box">
        <label for="image">ç¬¬ä¸€æ­¥ï¼šå…ˆé€‰æ‹©æœ¬åœ°å›¾ç‰‡(å¯å¤šé€‰)</label>
        <input type="file" id="image" autocomplete="off" multiple 
       style="
           padding: 8px 16px;
           background-color: #4CAF50;
           color: white;
           border: none;
           border-radius: 4px;
           cursor: pointer;
           font-size: 1rem;
           transition: background-color 0.3s;
           box-shadow: 0 2px 4px rgba(0,0,0,0.1);
       "
       onmouseover="this.style.backgroundColor='#45a049'"
       onmouseout="this.style.backgroundColor='#4CAF50'">
        <label for="text">ç¬¬äºŒæ­¥ï¼šè¾“å…¥éœ€è¦æ‰“æ°´å°çš„æ–‡å­—</label>
        <input id="text" autocomplete="off" placeholder="è¯·è¾“å…¥æ–‡å­—">
    </div>

    <div class="align-center-box">
        <div class="control-group">
            <label for="color">é¢œè‰²</label>
            <input type="color" id="color" value="#000000">
            <label class="label" id="label-color"></label>
        </div>

        <div class="control-group">
            <label for="fontSelect">å­—ä½“</label>
            <select id="fontSelect"></select>
        </div>

        <div class="control-group">
            <label for="alpha">é€æ˜åº¦</label>
            <input type="range" id="alpha" min="0" max="1" step="0.01" autocomplete="off" value="0.25">
            <label class="label" id="label-alpha"></label>
        </div>

        <div class="control-group">
            <label for="size">å­—å·</label>
            <input type="range" id="size" min="0.1" max="5" step="0.01" autocomplete="off" value="0.8">
            <label class="label" id="label-size"></label>
        </div>

        <div class="control-group">
            <label for="marginVertical">é—´éš”</label>
            <input type="range" id="marginVertical" min="-5" max="12" step="0.1" autocomplete="off" value="3.3">
            <label class="label" id="label-marginVertical"></label>
        </div>
    </div>

    <div class="align-center-box">
        <label for="text">ç¬¬ä¸‰æ­¥ï¼šæ‰‹æœºç«¯ç‚¹å‡»å›¾ç‰‡è¿›è¡Œå•ä¸ªå›¾ç‰‡ä¸‹è½½ï¼Œç”µè„‘ç«¯å¯ä¸‹è½½å…¨éƒ¨</label>
        <button onclick="downloadAllPic()" 
        style="
            padding: 8px 16px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        "
        onmouseover="this.style.backgroundColor='#0b7dda'"
        onmouseout="this.style.backgroundColor='#2196F3'">
    ä¸‹è½½å…¨éƒ¨
</button>
        <div class="format-group">
            <label>
                PNGæ ¼å¼
                <input type="radio" value="image/png" name="pic-type" class="pic-type">
            </label>
            <label>
                JPEGæ ¼å¼
                <input type="radio" value="image/jpeg" name="pic-type" class="pic-type" checked>
            </label>
            <label>
                Webpæ ¼å¼
                <input type="radio" value="image/webp" name="pic-type" class="pic-type">
            </label>
        </div>
        <span id="pic-quality-div" style="display: block">
            <label for="pic-quality">å›¾åƒè´¨é‡</label>
            <input type="range" id="pic-quality" min="1" max="100" step="1" autocomplete="off" value="95">
            <label class="label" id="label-pic-quality"></label>
        </span>
    </div>

    <p id="graph"></p>

    <script>
        let canvas;
        let $ = sel => document.querySelector(sel);
        let inputItems = ['color', 'alpha', 'size', 'marginVertical', 'pic-quality'];
        let configInputSetting = {};
        let allCanvas = [];

        let image = $('#image');
        let graph = $('#graph');
        let dataURItoBlob = (dataURI, type) => {
            let binStr = atob(dataURI.split(',')[1]);
            let len = binStr.length;
            let arr = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                arr[i] = binStr.charCodeAt(i);
            }
            return new Blob([arr], { type });
        };

        const fontOptions = ["Arial", "Helvetica", "Times New Roman", "Courier New", "Verdana", "Georgia", "Impact", "Tahoma", "Palatino", "Garamond", "Bookman", "Comic Sans MS", "Century Gothic", "Arial Black", "Lucida Console",
            "å¹¼åœ†", "æ–°å®‹ä½“", "æ–‡æ³‰é©¿å¾®ç±³é»‘", "å¾®è½¯æ­£é»‘ä½“", "å¾®è½¯é›…é»‘", "å®‹ä½“", "æ€æºå®‹ä½“", "æ€æºé»‘ä½“", "è‹¹æ–¹", "éš¶ä¹¦", "æ¥·ä½“", "å¼€æºå­—ä½“", "åæ–‡ä¸­å®‹", "åæ–‡è¡Œæ¥·", "åæ–‡æ–°é­", "åæ–‡ç»†é»‘", "åæ–‡å®‹ä½“", "åæ–‡éš¶ä¹¦", "åæ–‡æ¥·ä½“", "åæ–‡ç¥ç€", "åæ–‡é»‘ä½“", "åæ–‡ä»¿å®‹", "åæ–‡å½©äº‘", "é»‘ä½“", "æ±‰ä»ªé›…é…·é»‘W", "æ±‰ä»ªå°éº¦ä½“", "æ±‰ä»ªå°šé­æ‰‹ä¹¦W", "æ±‰ä»ªæ——é»‘", "æ±‰ä»ªä¹å–µä½“ç®€", "æ±‰ä»ªæ¥·ä½“", "æ±‰ä»ªå®¶ä¹¦ç®€", "æ±‰ä»ªé»‘è”æ", "æ±‰ä»ªå¤§å®‹ç®€", "æ±‰ä»ªå¤§é»‘ç®€", "æ±‰ä»ªç¨‹è¡Œä½“", "æ±‰ä»ªPPä½“ç®€", "ä»¿å®‹"];
        const selectElement = $("#fontSelect");
        for (let i = 0; i < fontOptions.length; i++) {
            const optionElement = document.createElement("option");
            optionElement.value = fontOptions[i];
            optionElement.textContent = fontOptions[i];
            optionElement.style.fontFamily = fontOptions[i];
            selectElement.appendChild(optionElement);
        }

        const redrawCanvas = (canvas, img, scaledWidth, scaledHeight) => {
            const dpr = window.devicePixelRatio || 1;
            // Set canvas pixel dimensions
            canvas.width = scaledWidth * dpr;
            canvas.height = scaledHeight * dpr;
            // Set CSS dimensions to maintain aspect ratio
            canvas.style.width = `${scaledWidth}px`;
            canvas.style.height = `${scaledHeight}px`;
            let ctx = canvas.getContext('2d', { alpha: true, desynchronized: false });
            ctx.scale(dpr, dpr);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
        };

        const downloadCanvasAsImage = (canvas, fileName) => {
            let type = configInputSetting["pic-type"] || "image/jpeg";
            let link = document.createElement('a');
            link.download = fileName + "_watermark." + type.split("/")[1];
            let quality = type === "image/png" ? undefined : parseFloat($("#pic-quality").value) / 100;
            let imageData = canvas.toDataURL(type, quality);
            let blob = dataURItoBlob(imageData, type);
            link.href = URL.createObjectURL(blob);
            graph.appendChild(link);
            setTimeout(() => {
                link.click();
                graph.removeChild(link);
            }, 10);
        };

        const downloadAllPic = async () => {
            allCanvas.forEach(({canvas, img, fileName}) => {
                downloadCanvasAsImage(canvas, fileName);
            });
        };

        let readFile = file => {
            if (!file) {
                console.error('No file provided');
                return;
            }
            try {
                let fileReader = new FileReader();
                fileReader.onload = function () {
                    try {
                        let img = new Image();
                        img.onload = function () {
                            try {
                                const canvas = document.createElement('canvas');
                                let scaledWidth = img.width;
                                let scaledHeight = img.height;

                                // Adjust size for mobile devices to fit screen
                                const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                                if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                                    const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                                    scaledWidth = Math.round(scaledWidth * ratio);
                                    scaledHeight = Math.round(scaledHeight * ratio);
                                }

                                redrawCanvas(canvas, img, scaledWidth, scaledHeight);
                                allCanvas.push({img, canvas, fileName: file.name});

                                drawText(canvas, img, scaledWidth, scaledHeight);
                                graph.appendChild(canvas);
                                console.log(`Canvas for ${file.name} appended to #graph`);

                                canvas.addEventListener('click', () => downloadCanvasAsImage(canvas, file.name));
                            } catch (err) {
                                console.error(`Error processing image ${file.name}:`, err);
                                alert(`å¤„ç†å›¾ç‰‡ ${file.name} æ—¶å‡ºé”™: ${err.message}`);
                            }
                        };
                        img.onerror = function () {
                            console.error(`Failed to load image ${file.name}`);
                            alert(`æ— æ³•åŠ è½½å›¾ç‰‡ ${file.name}ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®`);
                        };
                        img.src = fileReader.result;
                    } catch (err) {
                        console.error(`Error in image creation for ${file.name}:`, err);
                        alert(`åˆ›å»ºå›¾ç‰‡ ${file.name} æ—¶å‡ºé”™: ${err.message}`);
                    }
                };
                fileReader.onerror = function () {
                    console.error(`Failed to read file ${file.name}`);
                    alert(`è¯»å–æ–‡ä»¶ ${file.name} å¤±è´¥`);
                };
                fileReader.readAsDataURL(file);
            } catch (err) {
                console.error(`Error in readFile for ${file.name}:`, err);
                alert(`å¤„ç†æ–‡ä»¶ ${file.name} æ—¶å‡ºé”™: ${err.message}`);
            }
        };

        const makeStyle = () => {
            let match = configInputSetting.color.value.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
            return 'rgba(' + parseInt(match[1], 16) + ',' + parseInt(match[2], 16) + ',' + parseInt(match[3], 16) + ',' + configInputSetting.alpha.value + ')';
        };

        const drawText = (canvas, img, scaledWidth, scaledHeight) => {
            redrawCanvas(canvas, img, scaledWidth, scaledHeight);
            if (!canvas) {
                return;
            }

            let textSize = configInputSetting.size.value * Math.max(15, Math.min(scaledWidth, scaledHeight) / 25);
            let textCtx = canvas.getContext('2d', { alpha: true });
            textCtx.fillStyle = makeStyle();
            textCtx.font = textSize + "px " + $("#fontSelect").value;
            textCtx.textRendering = 'optimizeLegibility';
            textCtx.textBaseline = 'middle';

            let baseWidth = textCtx.measureText('å•Š').width;
            let textWidth = textCtx.measureText(configInputSetting.text.value).width;
            let xAdd = textWidth + baseWidth;
            let yAdd = textWidth + configInputSetting.marginVertical.value * baseWidth;
            xAdd = Math.max(xAdd, 10);
            yAdd = Math.max(yAdd, 10);

            let border = 500;
            for (let i = -border; i < scaledWidth + border; i += xAdd) {
                for (let j = -border; j < scaledHeight + border; j += yAdd) {
                    textCtx.save();
                    textCtx.translate(i, j);
                    textCtx.fillText(configInputSetting.text.value, 0, 0);
                    textCtx.restore();
                }
            }
        };

        let picTypeInputs = document.getElementsByClassName("pic-type");
        for (let i = 0; i < picTypeInputs.length; i++) {
            let item = picTypeInputs[i];
            item.addEventListener('change', () => {
                let picQuality = $("#pic-quality-div");
                picQuality.style.display = "none";
                if (item.checked) {
                    configInputSetting["pic-type"] = item.value;
                    if ("image/webp" === item.value || "image/jpeg" === item.value) {
                        picQuality.style.display = "";
                    }
                }
            });
        }

        image.addEventListener('change', function () {
            if (!this.files || this.files.length === 0) {
                console.warn('No files selected');
                alert('æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶');
                return;
            }
            const batchFileHandler = file => {
                const type = file.type.toLowerCase();
                if (!['image/png', 'image/jpeg', 'image/webp'].includes(type)) {
                    console.warn(`Unsupported file type for ${file.name}: ${type}`);
                    alert(`æ–‡ä»¶ ${file.name} çš„æ ¼å¼ä¸å—æ”¯æŒï¼Œä»…æ”¯æŒ PNGã€JPEGã€WebP`);
                    return;
                }
                readFile(file);
            };
            Array.from(this.files).forEach(batchFileHandler);
        });

        configInputSetting["text"] = $('#text');
        configInputSetting["text"].addEventListener('input', () => {
            allCanvas.forEach(({canvas, img, scaledWidth, scaledHeight}) => {
                scaledWidth = img.width;
                scaledHeight = img.height;
                const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                    const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                    scaledWidth = Math.round(scaledWidth * ratio);
                    scaledHeight = Math.round(scaledHeight * ratio);
                }
                drawText(canvas, img, scaledWidth, scaledHeight);
            });
        });

        configInputSetting["fontSelect"] = $('#fontSelect');
        configInputSetting["fontSelect"].addEventListener('change', () => {
            allCanvas.forEach(({canvas, img, scaledWidth, scaledHeight}) => {
                scaledWidth = img.width;
                scaledHeight = img.height;
                const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                    const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                    scaledWidth = Math.round(scaledWidth * ratio);
                    scaledHeight = Math.round(scaledHeight * ratio);
                }
                drawText(canvas, img, scaledWidth, scaledHeight);
            });
        });

        inputItems.forEach(item => {
            let el = $('#' + item);
            configInputSetting[item] = el;
            let labelDom = "#label-" + item;
            $(labelDom) ? $(labelDom).innerText = isNaN(el.value) ? el.value : parseFloat(el.value).toFixed(2) : "";
            return el.addEventListener('input', () => {
                $(labelDom) ? $(labelDom).innerText = isNaN(el.value) ? el.value : parseFloat(el.value).toFixed(2) : "";
                allCanvas.forEach(({canvas, img, scaledWidth, scaledHeight}) => {
                    scaledWidth = img.width;
                    scaledHeight = img.height;
                    const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                    if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                        const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                        scaledWidth = Math.round(scaledWidth * ratio);
                        scaledHeight = Math.round(scaledHeight * ratio);
                    }
                    drawText(canvas, img, scaledWidth, scaledHeight);
                });
            });
        });
    </script>
</div>
<script>
(function(){
  const KEY = 'watermark_theme'; // 'light' | 'dark' | 'system'(æˆ–null)

  // â€”â€” åº”ç”¨ä¸»é¢˜ â€”â€” 
  function applyTheme(mode){
    if(mode === 'dark'){ document.documentElement.setAttribute('data-theme','dark'); return; }
    if(mode === 'light'){ document.documentElement.setAttribute('data-theme','light'); return; }
    // è·Ÿéšç³»ç»Ÿ
    const prefersDark = matchMedia('(prefers-color-scheme: dark)').matches;
    document.documentElement.setAttribute('data-theme', prefersDark ? 'dark' : 'light');
  }

  // â€”â€” åˆå§‹åŒ–ï¼šä¼˜å…ˆæœ¬åœ°è®°å¿†ï¼Œå¦åˆ™è·Ÿéšç³»ç»Ÿ â€”â€” 
  const saved = localStorage.getItem(KEY) || 'system';
  applyTheme(saved);

  // â€”â€” å½“æœªæ‰‹åŠ¨æŒ‡å®šæ—¶ï¼Œè·Ÿéšç³»ç»Ÿå˜åŒ– â€”â€” 
  try{
    const mq = matchMedia('(prefers-color-scheme: dark)');
    mq.addEventListener?.('change', () => {
      if((localStorage.getItem(KEY) || 'system') === 'system') applyTheme('system');
    });
  }catch{}

  // â€”â€” æ”¾ä¸€ä¸ªå³ä¸Šè§’â€œğŸŒ“â€å¼€å…³ï¼šlight â†’ dark â†’ system å¾ªç¯ â€”â€” 
  if(!document.querySelector('.theme-toggle')){
    const btn = document.createElement('div');
    btn.className = 'mini-fab theme-toggle';
    btn.title = 'åˆ‡æ¢ä¸»é¢˜ï¼ˆæµ…è‰²/æ·±è‰²/è·Ÿéšç³»ç»Ÿï¼‰';
    btn.textContent = 'ğŸŒ“';
    btn.addEventListener('click', () => {
      const cur = localStorage.getItem(KEY) || 'system';
      const next = cur === 'light' ? 'dark' : (cur === 'dark' ? 'system' : 'light');
      if(next === 'system') localStorage.removeItem(KEY); else localStorage.setItem(KEY, next);
      applyTheme(next);
    });
    document.body.appendChild(btn);
  }

  // â€”â€” ï¼ˆå¯é€‰ï¼‰å·¦ä¸Šè§’â€œÃ—â€å…³é—­é’®ï¼Œå¦‚æœè¿˜æ²¡åŠ å°±è¡¥ä¸€ä¸ª â€”â€” 
  if(!document.querySelector('.close-x')){
    const x = document.createElement('div');
    x.className = 'mini-fab close-x';
    x.setAttribute('aria-label','å…³é—­');
    x.textContent = 'Ã—';
    x.addEventListener('click', () => {
      window.close();
      setTimeout(() => {
        if (!document.hidden) {
          if (history.length > 1) history.back();
          else location.href = '/';
        }
      }, 150);
    });
    document.body.appendChild(x);
  }
})();
</script>
</body>
</html>