<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
    <title>离线图片水印工具</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
        }

        #container {
            max-width: 1200px;
            margin: 0 auto;
        }

        #graph {
            display: grid;
            grid-gap: 10px;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }

        p, article {
            margin: 0 0 1.5rem 0;
        }

        article {
            font-size: 0.9rem;
            color: #777;
        }

        .align-center-box {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 1rem;
            gap: 10px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-right: 20px;
        }

        label {
            color: blue;
            font-size: 1.1rem;
            margin-right: 10px;
        }

        .control-group label, .format-group label {
            color: black;
            font-size: 1rem;
            min-width: 80px;
        }

        input#text {
            width: 100%;
            box-sizing: border-box;
            font-size: 1rem;
            padding: 8px;
            margin-bottom: 10px;
        }

        input[type=range] {
            width: 350px;
            height: 18px;
            vertical-align: middle;
        }

        input[type=color] {
            width: 40px;
            height: 40px;
            padding: 0;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid blue;
        }

        select {
            width: 250px;
        }

        canvas {
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            height: auto; /* 保持宽高比 */
            border: 1px dashed #AAA;
            cursor: pointer;
            display: block; /* 防止 inline 样式导致偏移 */
        }

        .label {
            min-width: 50px;
        }

        button {
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
        }

        select, input[type=file], input[type=checkbox], input[type=radio] {
            font-size: 1rem;
            padding: 5px;
        }

        .format-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        @media (max-width: 768px) {
            #container {
                padding: 10px;
            }

            #graph {
                grid-template-columns: 1fr;
            }

            .align-center-box {
                flex-direction: column;
                align-items: flex-start;
            }

            .control-group {
                flex-direction: row;
                width: 100%;
                margin-right: 0;
            }

            .control-group label, .format-group label {
                font-size: 0.9rem;
                min-width: 70px;
            }

            input[type=range] {
                width: 270px;
            }

            select {
                width: 100%;
                max-width: 200px;
            }

            input[type=color] {
                width: 35px;
                height: 35px;
                border-radius: 50%;
                border: 2px solid blue;
            }

            button, select, input[type=file], input#text {
                width: 100%;
                box-sizing: border-box;
            }

            .label {
                min-width: 40px;
            }

            h1 {
                font-size: 1.5rem;
            }

            article {
                font-size: 0.85rem;
            }

            .format-group {
                flex-wrap: wrap;
                gap: 10px;
            }

            canvas {
                max-width: 100%;
                height: auto; /* 确保移动端保持宽高比 */
            }
        }

        @media (max-width: 480px) {
            label {
                font-size: 0.9rem;
            }

            .control-group label, .format-group label {
                font-size: 0.8rem;
                min-width: 60px;
            }

            button, select, input {
                font-size: 0.9rem;
            }

            input[type=range] {
                width: 230px;
            }

            select {
                width: 100%;
                max-width: 180px;
            }

            input[type=color] {
                width: 30px;
                height: 30px;
                border-radius: 50%;
                border: 2px solid blue;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
    
    <style id="pwa-dark-style">
  :root {
    --bg: #ffffff;
    --fg: #111111;
    --muted: #777777;
    --border: #AAAAAA;
  }
  html[data-theme="dark"]{
    --bg: #0f1115;
    --fg: #eaeaea;
    --muted: #b9b9b9;
    --border: #3a3f44;
  }
  /* 全局（不覆盖你原有的） */
  body { background: var(--bg); color: var(--fg); }
  article { color: var(--muted); }
  label { color: var(--fg); }
  canvas { border-color: var(--border); }
  select, input[type="text"], input[type="range"], input[type="file"]{
    color: var(--fg);
    background: transparent;
  }

  /* 顶部工具条（仅 PWA 时注入） */
  .pwa-header {
    position: sticky; /* 不抢你布局流；较老机型可改 fixed */
    top: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    gap: .5rem;
    padding: .5rem .75rem;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
    -webkit-user-select: none;
    user-select: none;
  }
  .pwa-header .title {
    font-size: 14px;
    opacity: .8;
    margin-left: .25rem;
  }
  .pwa-header .spacer { flex: 1; }
  .pwa-btn {
    padding: .4rem .8rem;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--fg);
    font-size: 14px;
    cursor: pointer;
  }
  .pwa-btn.primary { border-color: #2196F3; }
  .pwa-btn:active { transform: translateY(1px); }
</style>
</head>
<body>
<div id="container">
    <h1>离线图片水印工具</h1>
    <article>
        安全地为图片加水印，无任何网络请求，特别适合各种敏感证件（身份证，驾照，护照等）。
    </article>

    <div class="align-center-box">
        <label for="image">第一步：先选择本地图片(可多选)</label>
        <input type="file" id="image" autocomplete="off" multiple 
       style="
           padding: 8px 16px;
           background-color: #4CAF50;
           color: white;
           border: none;
           border-radius: 4px;
           cursor: pointer;
           font-size: 1rem;
           transition: background-color 0.3s;
           box-shadow: 0 2px 4px rgba(0,0,0,0.1);
       "
       onmouseover="this.style.backgroundColor='#45a049'"
       onmouseout="this.style.backgroundColor='#4CAF50'">
        <label for="text">第二步：输入需要打水印的文字</label>
        <input id="text" autocomplete="off" placeholder="请输入文字">
    </div>

    <div class="align-center-box">
        <div class="control-group">
            <label for="color">颜色</label>
            <input type="color" id="color" value="#000000">
            <label class="label" id="label-color"></label>
        </div>

        <div class="control-group">
            <label for="fontSelect">字体</label>
            <select id="fontSelect"></select>
        </div>

        <div class="control-group">
            <label for="alpha">透明度</label>
            <input type="range" id="alpha" min="0" max="1" step="0.01" autocomplete="off" value="0.25">
            <label class="label" id="label-alpha"></label>
        </div>

        <div class="control-group">
            <label for="size">字号</label>
            <input type="range" id="size" min="0.1" max="5" step="0.01" autocomplete="off" value="0.8">
            <label class="label" id="label-size"></label>
        </div>

        <div class="control-group">
            <label for="marginVertical">间隔</label>
            <input type="range" id="marginVertical" min="-5" max="12" step="0.1" autocomplete="off" value="3.3">
            <label class="label" id="label-marginVertical"></label>
        </div>
    </div>

    <div class="align-center-box">
        <label for="text">第三步：手机端点击图片进行单个图片下载，电脑端可下载全部</label>
        <button onclick="downloadAllPic()" 
        style="
            padding: 8px 16px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        "
        onmouseover="this.style.backgroundColor='#0b7dda'"
        onmouseout="this.style.backgroundColor='#2196F3'">
    下载全部
</button>
        <div class="format-group">
            <label>
                PNG格式
                <input type="radio" value="image/png" name="pic-type" class="pic-type">
            </label>
            <label>
                JPEG格式
                <input type="radio" value="image/jpeg" name="pic-type" class="pic-type" checked>
            </label>
            <label>
                Webp格式
                <input type="radio" value="image/webp" name="pic-type" class="pic-type">
            </label>
        </div>
        <span id="pic-quality-div" style="display: block">
            <label for="pic-quality">图像质量</label>
            <input type="range" id="pic-quality" min="1" max="100" step="1" autocomplete="off" value="95">
            <label class="label" id="label-pic-quality"></label>
        </span>
    </div>

    <p id="graph"></p>

    <script>
        let canvas;
        let $ = sel => document.querySelector(sel);
        let inputItems = ['color', 'alpha', 'size', 'marginVertical', 'pic-quality'];
        let configInputSetting = {};
        let allCanvas = [];

        let image = $('#image');
        let graph = $('#graph');
        let dataURItoBlob = (dataURI, type) => {
            let binStr = atob(dataURI.split(',')[1]);
            let len = binStr.length;
            let arr = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                arr[i] = binStr.charCodeAt(i);
            }
            return new Blob([arr], { type });
        };

        const fontOptions = ["Arial", "Helvetica", "Times New Roman", "Courier New", "Verdana", "Georgia", "Impact", "Tahoma", "Palatino", "Garamond", "Bookman", "Comic Sans MS", "Century Gothic", "Arial Black", "Lucida Console",
            "幼圆", "新宋体", "文泉驿微米黑", "微软正黑体", "微软雅黑", "宋体", "思源宋体", "思源黑体", "苹方", "隶书", "楷体", "开源字体", "华文中宋", "华文行楷", "华文新魏", "华文细黑", "华文宋体", "华文隶书", "华文楷体", "华文琥珀", "华文黑体", "华文仿宋", "华文彩云", "黑体", "汉仪雅酷黑W", "汉仪小麦体", "汉仪尚魏手书W", "汉仪旗黑", "汉仪乐喵体简", "汉仪楷体", "汉仪家书简", "汉仪黑荔枝", "汉仪大宋简", "汉仪大黑简", "汉仪程行体", "汉仪PP体简", "仿宋"];
        const selectElement = $("#fontSelect");
        for (let i = 0; i < fontOptions.length; i++) {
            const optionElement = document.createElement("option");
            optionElement.value = fontOptions[i];
            optionElement.textContent = fontOptions[i];
            optionElement.style.fontFamily = fontOptions[i];
            selectElement.appendChild(optionElement);
        }

        const redrawCanvas = (canvas, img, scaledWidth, scaledHeight) => {
            const dpr = window.devicePixelRatio || 1;
            // Set canvas pixel dimensions
            canvas.width = scaledWidth * dpr;
            canvas.height = scaledHeight * dpr;
            // Set CSS dimensions to maintain aspect ratio
            canvas.style.width = `${scaledWidth}px`;
            canvas.style.height = `${scaledHeight}px`;
            let ctx = canvas.getContext('2d', { alpha: true, desynchronized: false });
            ctx.scale(dpr, dpr);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
        };

        const downloadCanvasAsImage = (canvas, fileName) => {
            let type = configInputSetting["pic-type"] || "image/jpeg";
            let link = document.createElement('a');
            link.download = fileName + "_watermark." + type.split("/")[1];
            let quality = type === "image/png" ? undefined : parseFloat($("#pic-quality").value) / 100;
            let imageData = canvas.toDataURL(type, quality);
            let blob = dataURItoBlob(imageData, type);
            link.href = URL.createObjectURL(blob);
            graph.appendChild(link);
            setTimeout(() => {
                link.click();
                graph.removeChild(link);
            }, 10);
        };

        const downloadAllPic = async () => {
            allCanvas.forEach(({canvas, img, fileName}) => {
                downloadCanvasAsImage(canvas, fileName);
            });
        };

        let readFile = file => {
            if (!file) {
                console.error('No file provided');
                return;
            }
            try {
                let fileReader = new FileReader();
                fileReader.onload = function () {
                    try {
                        let img = new Image();
                        img.onload = function () {
                            try {
                                const canvas = document.createElement('canvas');
                                let scaledWidth = img.width;
                                let scaledHeight = img.height;

                                // Adjust size for mobile devices to fit screen
                                const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                                if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                                    const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                                    scaledWidth = Math.round(scaledWidth * ratio);
                                    scaledHeight = Math.round(scaledHeight * ratio);
                                }

                                redrawCanvas(canvas, img, scaledWidth, scaledHeight);
                                allCanvas.push({img, canvas, fileName: file.name});

                                drawText(canvas, img, scaledWidth, scaledHeight);
                                graph.appendChild(canvas);
                                console.log(`Canvas for ${file.name} appended to #graph`);

                                canvas.addEventListener('click', () => downloadCanvasAsImage(canvas, file.name));
                            } catch (err) {
                                console.error(`Error processing image ${file.name}:`, err);
                                alert(`处理图片 ${file.name} 时出错: ${err.message}`);
                            }
                        };
                        img.onerror = function () {
                            console.error(`Failed to load image ${file.name}`);
                            alert(`无法加载图片 ${file.name}，请确保文件格式正确`);
                        };
                        img.src = fileReader.result;
                    } catch (err) {
                        console.error(`Error in image creation for ${file.name}:`, err);
                        alert(`创建图片 ${file.name} 时出错: ${err.message}`);
                    }
                };
                fileReader.onerror = function () {
                    console.error(`Failed to read file ${file.name}`);
                    alert(`读取文件 ${file.name} 失败`);
                };
                fileReader.readAsDataURL(file);
            } catch (err) {
                console.error(`Error in readFile for ${file.name}:`, err);
                alert(`处理文件 ${file.name} 时出错: ${err.message}`);
            }
        };

        const makeStyle = () => {
            let match = configInputSetting.color.value.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
            return 'rgba(' + parseInt(match[1], 16) + ',' + parseInt(match[2], 16) + ',' + parseInt(match[3], 16) + ',' + configInputSetting.alpha.value + ')';
        };

        const drawText = (canvas, img, scaledWidth, scaledHeight) => {
            redrawCanvas(canvas, img, scaledWidth, scaledHeight);
            if (!canvas) {
                return;
            }

            let textSize = configInputSetting.size.value * Math.max(15, Math.min(scaledWidth, scaledHeight) / 25);
            let textCtx = canvas.getContext('2d', { alpha: true });
            textCtx.fillStyle = makeStyle();
            textCtx.font = textSize + "px " + $("#fontSelect").value;
            textCtx.textRendering = 'optimizeLegibility';
            textCtx.textBaseline = 'middle';

            let baseWidth = textCtx.measureText('啊').width;
            let textWidth = textCtx.measureText(configInputSetting.text.value).width;
            let xAdd = textWidth + baseWidth;
            let yAdd = textWidth + configInputSetting.marginVertical.value * baseWidth;
            xAdd = Math.max(xAdd, 10);
            yAdd = Math.max(yAdd, 10);

            let border = 500;
            for (let i = -border; i < scaledWidth + border; i += xAdd) {
                for (let j = -border; j < scaledHeight + border; j += yAdd) {
                    textCtx.save();
                    textCtx.translate(i, j);
                    textCtx.fillText(configInputSetting.text.value, 0, 0);
                    textCtx.restore();
                }
            }
        };

        let picTypeInputs = document.getElementsByClassName("pic-type");
        for (let i = 0; i < picTypeInputs.length; i++) {
            let item = picTypeInputs[i];
            item.addEventListener('change', () => {
                let picQuality = $("#pic-quality-div");
                picQuality.style.display = "none";
                if (item.checked) {
                    configInputSetting["pic-type"] = item.value;
                    if ("image/webp" === item.value || "image/jpeg" === item.value) {
                        picQuality.style.display = "";
                    }
                }
            });
        }

        image.addEventListener('change', function () {
            if (!this.files || this.files.length === 0) {
                console.warn('No files selected');
                alert('未选择任何文件');
                return;
            }
            const batchFileHandler = file => {
                const type = file.type.toLowerCase();
                if (!['image/png', 'image/jpeg', 'image/webp'].includes(type)) {
                    console.warn(`Unsupported file type for ${file.name}: ${type}`);
                    alert(`文件 ${file.name} 的格式不受支持，仅支持 PNG、JPEG、WebP`);
                    return;
                }
                readFile(file);
            };
            Array.from(this.files).forEach(batchFileHandler);
        });

        configInputSetting["text"] = $('#text');
        configInputSetting["text"].addEventListener('input', () => {
            allCanvas.forEach(({canvas, img, scaledWidth, scaledHeight}) => {
                scaledWidth = img.width;
                scaledHeight = img.height;
                const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                    const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                    scaledWidth = Math.round(scaledWidth * ratio);
                    scaledHeight = Math.round(scaledHeight * ratio);
                }
                drawText(canvas, img, scaledWidth, scaledHeight);
            });
        });

        configInputSetting["fontSelect"] = $('#fontSelect');
        configInputSetting["fontSelect"].addEventListener('change', () => {
            allCanvas.forEach(({canvas, img, scaledWidth, scaledHeight}) => {
                scaledWidth = img.width;
                scaledHeight = img.height;
                const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                    const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                    scaledWidth = Math.round(scaledWidth * ratio);
                    scaledHeight = Math.round(scaledHeight * ratio);
                }
                drawText(canvas, img, scaledWidth, scaledHeight);
            });
        });

        inputItems.forEach(item => {
            let el = $('#' + item);
            configInputSetting[item] = el;
            let labelDom = "#label-" + item;
            $(labelDom) ? $(labelDom).innerText = isNaN(el.value) ? el.value : parseFloat(el.value).toFixed(2) : "";
            return el.addEventListener('input', () => {
                $(labelDom) ? $(labelDom).innerText = isNaN(el.value) ? el.value : parseFloat(el.value).toFixed(2) : "";
                allCanvas.forEach(({canvas, img, scaledWidth, scaledHeight}) => {
                    scaledWidth = img.width;
                    scaledHeight = img.height;
                    const maxDimension = window.innerWidth < 768 ? Math.min(768, window.innerWidth) : 3840;
                    if (scaledWidth > maxDimension || scaledHeight > maxDimension) {
                        const ratio = Math.min(maxDimension / scaledWidth, maxDimension / scaledHeight);
                        scaledWidth = Math.round(scaledWidth * ratio);
                        scaledHeight = Math.round(scaledHeight * ratio);
                    }
                    drawText(canvas, img, scaledWidth, scaledHeight);
                });
            });
        });
    </script>
</div>
<script id="pwa-bridge">
(function () {
  // —— 兼容检测：是否处于 PWA（独立显示） ——
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches
                     || window.navigator.standalone === true;

  // —— 主题：读取/应用/监听系统偏好 ——
  const THEME_KEY = 'watermark_theme';
  function applyTheme(theme){
    document.documentElement.setAttribute('data-theme', theme);
  }
  function getSavedTheme(){
    return localStorage.getItem(THEME_KEY);
  }
  function getSystemTheme(){
    return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  }
  function initTheme(){
    const saved = getSavedTheme();
    applyTheme(saved || getSystemTheme());
  }
  initTheme();
  try {
    // 跟随系统改变
    if (window.matchMedia) {
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        const saved = getSavedTheme();
        if (!saved) applyTheme(e.matches ? 'dark' : 'light');
      });
    }
  } catch {}

  // —— PWA 顶部工具条：仅在 PWA 时注入，避免影响普通网页 ——
  if (isStandalone) {
    const bar = document.createElement('div');
    bar.className = 'pwa-header';
    bar.innerHTML = `
      <button class="pwa-btn" data-action="close">关闭</button>
      <button class="pwa-btn primary" data-action="done">完成</button>
      <span class="title">离线图片水印</span>
      <span class="spacer"></span>
      <button class="pwa-btn" data-action="theme">主题</button>
    `;
    // 插入到 body 顶部
    document.body.insertBefore(bar, document.body.firstChild);

    // 防止工具条遮挡内容：对于 sticky 一般不必，但保险起见可在容器加一点顶内边距
    const container = document.getElementById('container');
    if (container && getComputedStyle(container).paddingTop === '0px') {
      container.style.paddingTop = '8px';
    }

    // —— 交互逻辑（不改你现有函数名） ——
    function navigateBackOrHome(){
      // 优先返回；退无可退时，跳转到站点首页或上一层
      if (history.length > 1) history.back();
      else if (document.referrer) location.replace(document.referrer);
      else location.assign('/');
    }

    // *关闭*：单纯返回
    bar.querySelector('[data-action="close"]').addEventListener('click', () => {
      navigateBackOrHome();
    });

    // *完成*：先触发你已有的批量下载，再返回
    bar.querySelector('[data-action="done"]').addEventListener('click', async () => {
      try {
        if (typeof downloadAllPic === 'function') {
          await Promise.resolve(downloadAllPic());
        }
      } catch (e) {
        console.warn('downloadAllPic 发生异常（已忽略以保证可返回）：', e);
      } finally {
        // 给一点点时间让下载触发
        setTimeout(navigateBackOrHome, 200);
      }
    });

    // *主题*：在浅色/深色之间切换（再次点击可恢复跟随系统）
    bar.querySelector('[data-action="theme"]').addEventListener('click', () => {
      const current = document.documentElement.getAttribute('data-theme') || 'light';
      const next = current === 'dark' ? 'light' : 'dark';
      applyTheme(next);
      // 记忆选择；再次点击同一按钮三秒内连击三次可清除记忆（恢复跟随系统）
      localStorage.setItem(THEME_KEY, next);
      // 小彩蛋：快速三击清除手动选择
      let clicks = 0;
      const btn = bar.querySelector('[data-action="theme"]');
      const once = () => {
        clicks++;
        if (clicks >= 3) {
          clicks = 0;
          localStorage.removeItem(THEME_KEY);
          applyTheme(getSystemTheme());
          btn.removeEventListener('click', once, true);
          setTimeout(() => btn.addEventListener('click', once, true), 10); // 重新挂载
        }
        setTimeout(() => { clicks = 0; }, 1200);
      };
      btn.addEventListener('click', once, true);
    }, { once: true });
  }
})();
</script>
</body>
</html>